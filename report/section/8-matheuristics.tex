\section{Matheuristics}
\label{sec:matheuristics}

While exact methods provide optimality guarantees and meta-heuristics offer scalability, a third class of algorithms, known as \textit{Matheuristics}, combines the strengths of both.
These hybrid approaches exploit the mathematical programming capabilities of the CPLEX solver to explore specific, restricted neighborhoods defined by heuristic logic.
This project implements two primary matheuristic strategies: \textit{Hard Fixing} and \textit{Local Branching}.

Both strategies utilize a common initialization phase, managed by the \texttt{matheuristic\_utils} module.
Before invoking the exact solver, the algorithm runs a fast meta-heuristic to generate a high-quality initial solution.
This warm start is crucial: providing CPLEX with a tight upper bound allows the branch-and-cut engine to prune the search tree aggressively from the root node.

\subsection{Hard Fixing}

The Hard Fixing algorithm operates on the premise that a high-quality heuristic solution likely shares a significant number of edges with the global optimum.
Instead of requesting the solver to explore the complete solution space, this method iteratively fixes a large percentage of the decision variables to 1, effectively \("\)freezing\("\) random parts of the current best tour and asking CPLEX to optimize the remaining connections.

\paragraph*{Iterative Implementation and Hyperparameters}
Our implementation, detailed in Algorithm~\ref{alg:hard_fixing}, extends the basic concept into an iterative loop.
It starts with a warm-start solution generated by a fast meta-heuristic.
The algorithm then enters a loop that continues until the global time limit expires.
At each iteration, a new CPLEX model is constructed to ensure a clean state, and the edges of the current incumbent tour are fixed with probability $\rho$ (\texttt{rate}), creating a restricted sub-problem.
CPLEX explores this sub-problem using a time slice determined by \texttt{slice\_factor}, allowing multiple neighborhoods to be examined.
If a better solution is found, it becomes the new incumbent, shifting the center of the fixing procedure for the next iteration.
The algorithm is controlled by a few key hyperparameters: \texttt{heuristic} for the initial warm-start, \texttt{ratio} for the warm-start time fraction, \texttt{rate} for edge-fixing probability, \texttt{slice\_factor} for the fraction of remaining time per iteration, and \texttt{min\_slice} to ensure a minimum runtime for each CPLEX call.


\paragraph*{Convergence Behavior (Stochastic)}
Since Hard Fixing relies on random variable fixing, it acts as a \textit{stochastic search process}: the algorithm continues to iterate until the global time limit is strictly exhausted.
Even if a specific iteration fails to improve the objective function, the subsequent iteration generates (with high probability) a completely different sub-problem by fixing a new random subset of edges.
This characteristic allows the algorithm to potentially escape local optima by \("\)hopping\("\) between different subspaces, resulting in a continuous stream of potential improvements deep into the execution time.

\begin{algorithm}[H]
\caption{Hard Fixing Loop}
\label{alg:hard_fixing}
\SetAlgoLined
\DontPrintSemicolon
\KwIn{Instance $I$, Fixing Rate $\rho$, Time Limit $T_{max}$, Slice Factor $\sigma$, Min Slice $\tau_{min}$}
\KwOut{Best Tour $T_{best}$}

$T_{curr} \leftarrow$ RunMetaheuristic($I$)\;
$T_{best} \leftarrow T_{curr}$\;

\While{Time $< T_{max}$}{
    $M \leftarrow$ BuildCPLEXModel($I$)\;
    InjectMIPStart($M, T_{curr}$)\;

    \ForEach{edge $e=(u,v) \in T_{curr}$}{
        \If{Random(0,1) $< \rho$}{
            FixVariable($M, x_{uv}, 1.0$)\;
        }
    }

    $T_{slice} \leftarrow \max(\tau_{min}, \text{RemainingTime} \times \sigma)$\;
    SetTimeLimit($M, T_{slice}$)\;

    $x^* \leftarrow$ SolveMIP($M$)\;

    \If{SolutionFound($M$) \textbf{and} Cost($x^*$) $< Cost(T_{curr})$}{
        $T_{curr} \leftarrow$ ReconstructTour($x^*$)\;
        $T_{best} \leftarrow T_{curr}$\;
    }
    FreeModel($M$)\;
}
\Return $T_{best}$\;
\end{algorithm}

\subsection{Local Branching}

Local Branching, introduced by Fischetti and Lodi, formalizes the integration of local search within exact solvers.
Unlike Hard Fixing, which probabilistically locks specific variables, Local Branching constrains the search to a flexible neighborhood around the incumbent solution using a linear inequality.

The method relies on the definition of a $k$-OPT neighborhood within the ILP model.
Given a reference solution (the incumbent tour) with edge set $S$, we enforce the constraint $\sum_{e \in S} x_e \ge |S| - k$.
This forces the solver to find a new valid tour that discards at most $k$ edges from the current reference solution.

\paragraph*{Iterative Refinement and Hyperparameters}
Our implementation applies the Local Branching logic iteratively, as shown in Algorithm~\ref{alg:local_branching}.
The procedure enters a main loop that continues as long as improvements are found and time permits.
In each iteration, the Local Branching constraint is added relative to the current best tour $T_{curr}$, and CPLEX is invoked to explore this restricted neighborhood.
If an improving solution is found, it becomes the new reference point, centering the neighborhood on it for the next iteration.
The strategy is tuned through a few key hyperparameters: the \texttt{heuristic} for generating the initial solution, the \texttt{ratio} of execution time allocated to the warm-start, and \texttt{k}, the neighborhood size limiting the number of edges that can be swapped.


\paragraph*{Convergence Behavior (Deterministic)}
In contrast to Hard Fixing, Local Branching defines a \textit{deterministic neighborhood} based on the Hamming distance ($k$) from the incumbent.
As observed in the logs, this algorithm may terminate early, well before the time limit expires.
This occurs when the exact solver proves that no better solution exists within the $k$-OPT neighborhood of the current incumbent.
In this scenario, the algorithm has reached a local optimum with respect to the neighborhood size $k$.
Unlike Hard Fixing, repeating the iteration would be futile as the sub-problem remains identical.
To proceed further, one would need to dynamically increase $k$, but in the standard fixed-$k$ implementation, early termination serves as a proof of local optimality.

\begin{algorithm}[H]
\caption{Local Branching Loop}
\label{alg:local_branching}
\SetAlgoLined
\DontPrintSemicolon
\KwIn{Instance $I$, Neighborhood size $k$ (\texttt{k}), Time Limit $T_{max}$, Heuristic $H$, Ratio $r$}
\KwOut{Best Tour $T_{best}$}

$T_{curr} \leftarrow$ RunHeuristic($H, I, r \cdot T_{max}$)\;
$T_{best} \leftarrow T_{curr}$\;
$improved \leftarrow \textbf{true}$\;

\While{improved \textbf{and} Time $< T_{max}$}{
    $improved \leftarrow \textbf{false}$\;
    $M \leftarrow$ BuildCPLEXModel($I$)\;

    AddConstraint($M, \sum_{e \in T_{curr}} x_e \ge n - k$)\;
    SetTimeLimit($M, RemainingTime()$)\;

    $x^* \leftarrow$ SolveMIP($M$)\;

    \If{SolutionFound($M$) \textbf{and} Cost($x^*$) $< Cost(T_{curr})$}{
        $T_{curr} \leftarrow$ ReconstructTour($x^*$)\;
        $T_{best} \leftarrow T_{curr}$\;
        $improved \leftarrow \textbf{true}$\;
    }
    FreeModel($M$)\;
}
\Return $T_{best}$\;
\end{algorithm}